<!doctype html><html lang=en data-theme><head><title>Adam Mitha | Tackling Backtracking Search</title><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=description content="Software Developer"><link rel=stylesheet href=https://adammitha.com/css/style.min.0c643de4008adca329f7a2d616ce308cca99d4ef45e4cca307323e7857910194.css integrity="sha256-DGQ95ACK3KMp96LWFs4wjMqZ1O9F5MyjBzI+eFeRAZQ=" crossorigin=anonymous type=text/css><link rel=stylesheet href=https://adammitha.com/css/markupHighlight.min.f798cbda9aaa38f89eb38be6414bd082cfd71a6780375cbf67b6d2fb2b96491e.css integrity="sha256-95jL2pqqOPies4vmQUvQgs/XGmeAN1y/Z7bS+yuWSR4=" crossorigin=anonymous type=text/css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin=anonymous><link rel="shortcut icon" href=https://adammitha.com/favicons/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=https://adammitha.com/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://adammitha.com/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://adammitha.com/favicons/favicon-16x16.png><link rel=canonical href=https://adammitha.com/post/backtracking/><script type=text/javascript src=https://adammitha.com/js/anatole-header.min.df804b63b5bd8474ea0756ea874bc8f1e92552708cc6ea43aa0d76981dc419f9.js integrity="sha256-34BLY7W9hHTqB1bqh0vI8eklUnCMxupDqg12mB3EGfk=" crossorigin=anonymous></script>
<script type=text/javascript src=https://adammitha.com/js/anatole-theme-switcher.min.3829579c725749492568b0e6fa9da3012a7fc37fd291b4fd79e33c1df5d8a34a.js integrity="sha256-OClXnHJXSUklaLDm+p2jASp/w3/SkbT9eeM8HfXYo0o=" crossorigin=anonymous></script><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://adammitha.com/images/site-feature-image.png"><meta name=twitter:title content="Tackling Backtracking Search"><meta name=twitter:description content="An approach to solving backtracking search problems in Go."></head><body><div class="sidebar animated fadeInDown"><div class=logo-title><div class=title><img src=https://adammitha.com/images/profile.jpeg alt="profile picture"><h3 title><a href=/>Adam Mitha</a></h3><div class=description><p>Software Developer</p></div></div></div><ul class=social-links><li><a href=https://www.linkedin.com/in/adam-mitha-94286092/ rel=me aria-label=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li><a href=https://github.com/adammitha rel=me aria-label=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li><a href=https://twitter.com/adam_mitha rel=me aria-label=Twitter><i class="fab fa-twitter fa-2x" aria-hidden=true></i></a></li><li><a href=mailto:adam.mitha@gmail.com rel=me aria-label=e-mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul><div class=footer><div class=by_farbox>&copy; Adam Mitha 2023</div></div></div><div class=main><div class="page-top animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true></span>
<span aria-hidden=true></span>
<span aria-hidden=true></span></a><ul class=nav id=navMenu><li><a href=/ title>Home</a></li><li><a href=/post/ title>Posts</a></li><li><a href=/about/ title>About</a></li><li class=theme-switch-item><a class=theme-switch title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></li></ul></div><div class=autopagerize_page_element><div class=content><div class="post animated fadeInDown"><div class=post-content><div class=post-title><h3>Tackling Backtracking Search</h3><div class=info><em class="fas fa-calendar-day"></em>
<span class=date>Wed, Mar 31, 2021</span>
<em class="fas fa-stopwatch"></em>
<span class=reading-time>7-minute read</span></div></div><h2 id=introduction>Introduction</h2><p>Anyone who&rsquo;s taken CPSC 110 at UBC probably experiences a sense of dread when they hear about search problems. This is not an unreasonable response — backtracking search problems are among the hardest that you&rsquo;ll encounter on interview practice sites like <a href=http://www.leetcode.com>Leetcode</a>, so it seems almost cruel to expect first year computer science students (many of whom have never programmed in their life) to be able to tackle them. However, like with any other problem that you&rsquo;ll encounter in 110 (or in software engineering generally), having a structured approach to backtracking can help turn a seemingly gargantuan task into one that&rsquo;s quite digestible. There&rsquo;s only one way to eat an elephant — one bite at a time.</p><h3 id=premise>Premise</h3><p>The premise of backtracking search problems is to generate an n-ary (or arbitrary-arity) tree of potential solutions to our problem, and then searching through that generated tree to find our solution. As a quick reminder, an n-ary tree is a tree where each node can have an arbitrary number of children. This differs from a binary search tree, where each node has exactly two children.</p><h3 id=illustrative-exampe-n-queens>Illustrative exampe: N-Queens</h3><p>I&rsquo;ll be using the <a href=https://developers.google.com/optimization/cp/queens>N-Queens</a> problem to demonstrate my approach to backtracking search problems:</p><blockquote><p>How can N queens be placed on an NxN chessboard so that no two of them attack each other?</p></blockquote><p>For example, 4 queens can be placed on a 4x4 chess board like this:</p><figure><img src=/images/sol_4x4_b.png></figure><p>While this may seem intimidating at first, as you&rsquo;ll see a structured approach will make this problem much easier.</p><h3 id=tools>Tools</h3><p>I&rsquo;ll be using <a href=https://golang.org/>Go</a> to develop my solution to this problem, but I won&rsquo;t be using any third-party packages so you should be able to reproduce my solution in your language of choice.</p><h2 id=modelling-the-search-state>Modelling the search state</h2><p>The first step in any backtracking search problem is to determine what we are searching for, and how to best represent that in a data structure. This will represent the &rsquo;node&rsquo; in the tree of solutions we are searching through.</p><p>In the context of the N-queens problem, we are looking for a chess board that contains N-queens that cannot attack each other. A chess board is essentially a grid, which can be represented using a 2-dimensional array. We also need a way to represent which squares in the board contain a queen. This can be done using a boolean value — <code>true</code> means a queen is in that square, and <code>false</code> means it&rsquo;s empty.</p><p>A simple function can be used to generate an empty board of size N x N.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Queen represents position (row, column) of a Queen on a chess board
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Queen</span> <span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Board is a two-dimensional array of boolean values representing a chess board
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Board</span> <span class=p>[][]</span><span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// NewBoard creates an empty Board of size n x n
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>NewBoard</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=o>*</span><span class=nx>Board</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>board</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=nx>Board</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>board</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>board</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&amp;</span><span class=nx>board</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=generating-child-nodes>Generating child nodes</h2><p>The empty board we generated in step 1 will be our starting point – the root node of our search space. To generate candidate child nodes, fill each empty square with a queen and then verify if the board that we&rsquo;ve produced is valid. If we start with an empty 2 x 2 board, as our root, there are four valid child nodes that we can produce:</p><figure><img src=/images/child-nodes.png></figure><p>Once we&rsquo;ve generated the child nodes and eliminated any invalid boards, we will visit each one of them in turn and check if any of them represent a solved board – i.e. a board with N queens. Since any invalid boards have already been eliminated from the tree, if we encounter a board with N queens it&rsquo;s guaranteed to be a valid solution. This process can be repeated recursively until either a solution is found, or no valid child nodes can be generated. In our 2 x 2 example above, there is no valid arrangement of 2 queens such that they cannot attack each other, so the search would fail.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// nextBoards takes an existing board and creates a slice of new boards
</span></span></span><span class=line><span class=cl><span class=c1>// with each empty space filled with a queen.
</span></span></span><span class=line><span class=cl><span class=c1>// E.g.
</span></span></span><span class=line><span class=cl><span class=c1>// F F    T F  F T  F F  F F
</span></span></span><span class=line><span class=cl><span class=c1>// F F -&gt; F F, F F, T F, F T
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Board</span><span class=p>)</span> <span class=nf>nextBoards</span><span class=p>()</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Board</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=o>*</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>boards</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=o>*</span><span class=nx>Board</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Loop through b, fill every empty slot with a queen
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Check if slot already has a queen
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=nx>b</span><span class=p>)[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>continue</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Create a new board
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>newBoard</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>.</span><span class=nf>duplicate</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Fill slot with a new queen
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>newBoard</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Add board to list of boards if it is valid
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>if</span> <span class=nx>newBoard</span><span class=p>.</span><span class=nf>valid</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>boards</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>boards</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>newBoard</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>boards</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=validating-boards>Validating boards</h3><p>Before adding newly generated boards to the search space, we need to make sure that they&rsquo;re valid. This effectively means looping through each queen in the board and making sure that it doesn&rsquo;t attack any other queen on the board. We can eliminate queens with the same row or column index easily, and we can check diagonals by checking the absolute value of the difference in row and column indices. If both the row and column deltas are the same, the two queens are on a diagonal.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// valid returns true if all queens in the board cannot attack any other queen
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Board</span><span class=p>)</span> <span class=nf>valid</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=o>*</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Find indices of all queens in the board
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>queens</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=nx>Queen</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=nx>b</span><span class=p>)[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>queens</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>queens</span><span class=p>,</span> <span class=nx>Queen</span><span class=p>{</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>})</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>queen</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>queens</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>queens</span><span class=p>[</span><span class=nx>i</span><span class=p>:])</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>queen</span><span class=p>.</span><span class=nf>attacks</span><span class=p>(</span><span class=nx>queens</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>:])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// attacks checks if q attacks any of the queens
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>q</span> <span class=nx>Queen</span><span class=p>)</span> <span class=nf>attacks</span><span class=p>(</span><span class=nx>queens</span> <span class=p>[]</span><span class=nx>Queen</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>queen</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>queens</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>q</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=nx>queen</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>||</span> <span class=nx>q</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=nx>queen</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>||</span> <span class=nx>q</span><span class=p>.</span><span class=nf>diagonal</span><span class=p>(</span><span class=nx>queen</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// diagonal returns true if q and queen are on a shared diagonal
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>q</span> <span class=nx>Queen</span><span class=p>)</span> <span class=nf>diagonal</span><span class=p>(</span><span class=nx>queen</span> <span class=nx>Queen</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>dx</span> <span class=o>:=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>math</span><span class=p>.</span><span class=nf>Abs</span><span class=p>(</span><span class=nb>float64</span><span class=p>(</span><span class=nx>q</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=nx>queen</span><span class=p>[</span><span class=mi>1</span><span class=p>])))</span>
</span></span><span class=line><span class=cl>	<span class=nx>dy</span> <span class=o>:=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>math</span><span class=p>.</span><span class=nf>Abs</span><span class=p>(</span><span class=nb>float64</span><span class=p>(</span><span class=nx>q</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=nx>queen</span><span class=p>[</span><span class=mi>0</span><span class=p>])))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>dx</span> <span class=o>==</span> <span class=nx>dy</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=put-it-all-together>Put it all together</h2><p>Now that we know how to generate child nodes and check if they&rsquo;re valid, the last thing to do is put it all together into a search function.</p><p>At a high level, this function consumes a board and will do the following:</p><ol><li>Check the board to see if it&rsquo;s solved. If it is, return it. If not, proceed to step 2.</li><li>Generate child nodes</li><li>Recursively search each child node one by one, returning the result if a solution is found</li><li>If a solution cannot be found, return an error</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>search</span><span class=p>(</span><span class=nx>board</span> <span class=o>*</span><span class=nx>Board</span><span class=p>)</span> <span class=o>*</span><span class=nx>Board</span><span class=p>,</span> <span class=nx>err</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>board</span><span class=p>.</span><span class=nf>solved</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>board</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nx>nextBoards</span> <span class=o>:=</span> <span class=nx>board</span><span class=p>.</span><span class=nf>nextBoards</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>board</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nextBoards</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>solution</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>search</span><span class=p>(</span><span class=nx>board</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>continue</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>solution</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;unable to find a solution&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=conclusion>Conclusion</h2><p>Hopefully this post has helped you develop some intuition around search problems and given you a framework for approaching them in the future. You can check out a working implementation of the N-Queens solver we developed from my <a href=https://github.com/adammitha/n-queens>Github</a> if you want to see it in action. I would encourage you to try to solve this problem from scratch without referencing any of my code to ensure that you&rsquo;ve really grasped the concepts. If you&rsquo;re interested in checking out some other search problems, <a href=https://norvig.com/sudoku.html>Peter Norvig</a> has an excellent tutorial on building a Sudoku solver. If you have any suggestions for how to make this post better, feel free to reach out to me via <a href=mailto:adam.mitha@gmail.com>email</a> or <a href=https://twitter.com/adam_mitha>Twitter</a>. Happy searching!</p></div><div class=post-footer><div class=info><span class=separator><a class=category href=/categories/tutorials/>tutorials</a></span>
<span class=separator><a class=tag href=/tags/go/>Go</a></span></div></div></div></div></div></div><script type=text/javascript src=https://adammitha.com/js/jquery.min.decb4e8fdab5cb7b76ec6470b6fb73d30c7ee8e248d7486f49007f3c525b7acb.js integrity="sha256-3stOj9q1y3t27GRwtvtz0wx+6OJI10hvSQB/PFJbess=" crossorigin=anonymous></script>
<script type=text/javascript src=https://adammitha.com/js/bundle.min.3ebad6bf39b2e7c2f899d3ed9bc97e8c0c1ead7a1b57472e3387321f673b8077.js integrity="sha256-PrrWvzmy58L4mdPtm8l+jAwerXobV0cuM4cyH2c7gHc=" crossorigin=anonymous></script>
<script type=text/javascript src=https://adammitha.com/js/medium-zoom.min.e1c6918cbaa90022a5612f0bd71c7bf3be6d036614c5729cebfe14f7b91fa4bc.js integrity="sha256-4caRjLqpACKlYS8L1xx7875tA2YUxXKc6/4U97kfpLw=" crossorigin=anonymous></script></body></html>